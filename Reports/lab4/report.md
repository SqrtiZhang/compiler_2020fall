# Lab4 实验报告

小组成员：

闫超美 PB18061351

张永停 PB17111585

## 实验要求

<<<<<<< HEAD
1. 理解框架代码与 Cminusf 的语义，填写使用访问者模式的 `src/cminusf/cminusf_builder.cpp`，使编译出的 `cminusf` 可以编译 Cminusf 程序到 LLVM IR 或可执行文件。
2. 编写测试样例，确保在源程序符合 Cminusf 语义的情况下，`cminusf` 可以得到正确的结果。

## 实验难点

* 对访问者模式的理解，以及研究框架，要清楚流程就是访问AST来生成中间代码，在访问不同的节点时生成对应的代码，最终访问完后要能生成正确的LLVM IR。
* 全局变量的选择，不同的函数之间是有变量的传递的，这部分的传递一是可以在scope里做，当它们在同一个作用域里。也可以使用全局变量，保存访问前面的节点时需要传递的信息，比如当有多个函数的时候，会访问很多次Funcdeclaration节点，所以每次都要用一个全局变量来保存函数信息，表明是当前是在哪个函数里面，之后的选择和循环插入标签时就需要用到。
* 作用域问题，要搞清楚在哪里enter scope，在哪里退出scope。
* return的处理，比如在while和if里出现了return，那么这时候就不能再br了，不然可能会导致执行时寄存器编号出错。
* 类型转换，float当成int输入时需要自己对它做类型转换。
* 数组传参，数组传参要转化成指针传入。而且确定在什么时候转换比较难搞。
* 数组下标为负数时的检测。要在每一次遇到数组索引的情况都判断一次。
=======
<<<<<<< HEAD
1. 
=======
用 `LightIR` 框架自动产生 `cminus-f` 语言的LLVM IR
>>>>>>> 6cde002c25ba2f5ebbd4037ced4d13f5660fa48f

## 实验难点

- return的处理
  - 如果在 `ret` （`return` 语句产生）后面再接 `br` （`if` 语句产生）的话会导致 LLVM 的自动编号错误
- 数组和指针处理`ty*` `ty**` `[n x ty]`，这个虽然上次实验已经有所处理，还是耗时了一会
- 全局变量选择
- 
>>>>>>> zyt

## 实验设计

### 全局变量设计

因为LightIR的指令也是Value*类型，故实际用于传递中间值的全局变量只有一个 `Value *current_value`，还有一些其他类型的数据需要传递，所以加入了更多的全局变量。

1. current_value：作用就是传递框架中的中间变量，比如在assign的逻辑中，先是访问左值，然后在左值中要将得到的值传给current_value，然后在assign赋值操作中通过current_value来获得左值，这里左值通常是alloca的地址。然后再访问右值子节点，同样通过current_value来获得右值，最后再做赋值
2. current_type：当前的类型值
3. current_func：当前所在的函数体内
4. current_bb：当前所在的block内
5. return_alloca：返回时为返回值所声明的空间，需要传递后获得值后赋值
6. var_mode：用于从外部告诉 `syntax_var` 本次访问 var 是想要读还是写



### 难点的解决方案

#### 作用域问题

这里主要是看要在哪进入scope，一般来说在处理ASTCompoundStmt时，也就是{}时需要进入作用域，然后结束时要出作用域。还有就是在函数部分，也就是访问ASTFunDeclaration时，需要在定义好函数后进入scope，然后将函数的参数给push进去。在结束函数时出scope。

#### Var处理

因此我们只能从入口告诉 var 的处理函数：本次访问 var 是想读还是想写。这里有一个专门的全局变量，从 `factor` 进入前设成“读模式”，从 `assign_expression` 的左半部分进入前设成“写模式”，然后在 var 处理函数里获取该变量对应的 alloca；如果是读模式就额外创建一条 `load` 指令并返回；如果是写模式就直接返回该 alloca，以便外层创建 `store` 指令。

#### return处理

return 会产生 `ret` 指令，它是一个终结指令，因此当 return 出现在某些位置（例如 if 的分支中）时会产生额外的终结指令，导致 LLVM IR 的字段序号错误。

解决方案：在if和while处理完一个block后判断最后一条指令是否是ret指令，如果是就跳过br。主要是检查`trueBB->getTerminator()` 是不是 `nullptr`。

返回值的处理方式：先为返回值创建一个alloca，然后在得到返回值后填入这个地址。在函数体处理完毕之后将该块放到函数末尾。

#### 类型转换部分




### 实验总结

* 闫超美：学到了很多cpp的语法，以及对面向对象编程有了更加深入的理解，尤其是对访问者模式在生成中间代码的妙用有很大的触动，没有想到设计模式在写这种比较大的项目中带来的巨大的优势。同时对LightIR这个框架有了更多的了解，处理生成中间代码需要考虑到的边边角角的问题的能力有所提升。
* 张永停：

### 实验反馈 （可选 不会评分）

对本次实验的建议

### 组间交流 （可选）

本次实验和哪些组（记录组长学号）交流了哪一部分信息

